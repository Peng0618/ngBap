#'  Causal discovery with latent confounding and non-Gaussian data
#'
#' Estimates a graph from data generated by a linear SEM with non-Gaussian errors corresponding to a BAP
#'
#'
#' @param Y n x p matrix of observations with sample in row, variable in column
#' @param K The degree of the moment which is non-Gaussian (i.e., this is K in the paper). Only used if using empirical likelihood
#' @param level the nominal level for the empirical likelihood tests
#' @param verbose Print progress updates
#' @param restrict Which moment restrictions to test if using empirical likelihood
#'  \itemize{
#'  \item restrict = 1 restricts all moments up to degree K; i.e. gamma_v^k gamma_u and gamma_v gamma_u^k  for k < K
#'  \item restrict = 2, tests moments of degree K-1 and 1; i.e. gamma_v^(K-1) gamma_u and gamma_v gamma_u^(K-1)
#'}
#' @param sibsInit an initial estimate of the skeleton. If left null, the skeleton is initialized to the complete graph
#' @param testType the independence test used. either "empLik" for empirical likelihood, "dhsic" for dHSIC, or "dcov" for distance covariance
#' @return
#' \itemize{
#' \item totalEffect estimate of (I-B)^(-1)
#' \item directEffect estimate of B
#' \item omega estimate of Omega
#' \item dEdge estimate of adjacncey matrix corresponding to directed edges
#' \item bEdge estimate of adjacncey matrix corresponding to bidirected edges
#' \item errs estimated epsilons
#'}
#' @examples
#' \dontrun{
#' dat <- ngBap::rBAP(n = 50000, p = 7, dist = "gamma", d = 3, b = 5, ancestral = F, shuffle = T, signs = T)
#' Y <- dat$Y
#' out <- ngBap::bang(Y, K = 3, level = .01, verbose = F, restrict = 1)
#' }
#'
#'
#' @export
bang <- function(Y, K, level = .01, verbose = T, restrict = 1,
                 sibsInit = NULL, testType = "empLik"){

  if(verbose){
    cat("======= Estimating BAP ========\n")
  }
  p <- dim(Y)[2]
  n <- dim(Y)[1]


  ### directEffect is B matrix
  ### totalEffect is (I-B)^{-1}
  totalEffect <- directEffect <- matrix(0, nrow = p, ncol = p)
  diag(totalEffect) <- 1


  ### initialize to complete bidirected graph
  if(is.null(sibsInit)){

    siblings <- matrix(1, nrow = p, ncol = p)
    diag(siblings) <- 0

  } else {
    # If there is prior knowledge (i.e., some estimated skeleton)

    siblings <- sibsInit
  }

  # counter for set size
  l <- 1


  Y.orig <- Y


  while(any(rowSums(siblings) >= l)){
    old.Y <- Y


    # cycle through variables
      for (v in 1:p) {
        poss.pa <- which(siblings[v, ] != 0)
        if (verbose) {
          cat(paste("\n\n=== Checking ", v, " ===\n"))
          cat("Remaining siblings: ")
          cat(paste(poss.pa, collapse = " "))
          cat(paste("; sets of size: ", l, "\n"))
        }

        # prune anything that is indep
        if(length(poss.pa) > 0){
          testIndepResults <- sapply(poss.pa, testIndep, v, Y, Y.orig,
                                     K = K, verbose = verbose, restrict = restrict, testType = testType)

          if(verbose){
            cat("= Checking Independence =")
            prmatrix(rbind(as.character(paste(poss.pa,"     ", sep = "")), as.character(round(testIndepResults, 5))), quote = F,
                     rowlab = c("Sibling", "P-value"), collab = rep("", length(poss.pa)))
            cat("\n")

          }


          ## Remove independent nodes ##
          siblings[poss.pa[which(testIndepResults > level)], v] <-
            siblings[v, poss.pa[which(testIndepResults > level)]] <- 0


        } # End independence testing


        # Set the possible parents to be any nodes which are not certified and are not ancestors of v
        poss.pa <- setdiff(which(siblings[v, ] != 0), which(totalEffect[, v] != 0))

        if(length(poss.pa) >= l){



          # See if we've already checked all the remaining sets
            if(length(poss.pa) == 1){
              # if only 1 possible parent
              # combn gives unwanted result, so manually make matrix
              condSets <- matrix(c(poss.pa,
                                   which(directEffect[v, ] != 0)), ncol = 1)

            } else {
              condSets <- combn(poss.pa, l)
              condSets <- rbind(condSets, matrix(which(directEffect[v, ] != 0),
                                                 nrow = length(which(directEffect[v, ] != 0)),
                                                 ncol = dim(condSets)[2]))
            }


            ancestralCert <- apply(condSets, MAR = 2, testAncestorDebiased, v, Y,
                                   Y.orig, directEffect, totalEffect, K, verbose = verbose, restrict = restrict, testType = testType)

            if(verbose){
              cat("= Testing Ancestral =\n")
              tab <- rbind(apply(condSets, MAR = 2, paste, collapse = " "), round(ancestralCert, 4))
              prmatrix(tab, quote = F, rowlab = c("Ancestors", "P-value"), collab = rep("", dim(condSets)[2]))
              cat("\n")
            }


              certifiedParents <- unique(c(condSets[, which(ancestralCert > level)]))

              # Can be certified as unconfounded ancestor so cannot be a sibling
              siblings[v, certifiedParents] <- siblings[certifiedParents, v] <- 0



              # Update effec estimates
              update <- updateDebiased(certifiedParents, v, Y, Y.orig,
                                       directEffect, totalEffect, K)

              totalEffect <- update$totalEffect
              directEffect <- update$directEffect
              Y[, v] <- update$res.v


              if(verbose){
                cat("= Total Effect Estimates =\n")
                prmatrix(round(totalEffect, 4), rowlab = as.character(1:p), collab = as.character(1:p))

                cat("= Direct Effect Estimates =\n")
                prmatrix(round(directEffect, 4), rowlab = as.character(1:p), collab = as.character(1:p))
              }


          } # End if remaining siblings >= l for v
      } # end cycle through 1:p

    # If any updates were made to Y
    if(sum((old.Y - Y)^2) > 1e-5 ) {
      # reset counter to 1
      l <- 1
    } else {
      # else advance counter
      l <- l + 1
    }
  } # End big while for ANY sib(v) >= l



  #### Pruning Procedure #####
  ordering <- getOrdering(totalEffect)
  if(verbose){
    print("!!Pruning Procedure!!")
    print(ordering)
  }

  for(z in ordering){
    parents <- which(directEffect[z, ] != 0)
    if( length(parents) > 0){
    pruningStat <- sapply(parents, pruneParents, z, parents, Y, Y.orig, directEffect, totalEffect, K, verbose = verbose, restrict = restrict, testType = testType)


    certifiedParents <- parents[which(pruningStat < level)]
    if(length(certifiedParents) > 0){
      update <- updateDebiased(certifiedParents, z, Y, Y.orig,
                                 directEffect, totalEffect, K)

      totalEffect <- update$totalEffect
      directEffect <- update$directEffect
      Y[, z] <- update$res.v
    } else {

      # If no parents, remove all from directEffect and update totalEffect
      directEffect[z, ] <- 0
      totalEffect <- solve(diag(rep(1, p)) -  directEffect)
      Y[, z] <- Y.orig[, z]
    }

    if(verbose){
      cat(paste("Pruning:", z))

      print(parents)
      prmatrix(rbind(as.character(paste(parents,"     ", sep = "")), as.character(round(pruningStat, 5))), quote = F,
               rowlab = c("Parents", "P-value"), collab = rep("", length(parents)))
      cat("\n")

    }

    } else {
      if(verbose){
        cat(paste("Pruning:", z, "; no parents\n"))
      }
    }






  }


  return(list(totalEffect = totalEffect,
              directEffect = directEffect, omega = cov(Y), dEdge = ifelse(directEffect != 0, 1, 0),
              bEdge = siblings + diag(rep(1, p)), errs = Y))
}





#### Update ####
testIndep <- function(u, v, errs, Y, K,
                      verbose = F, restrict = 1, testType = "empLik"){

  if(testType == "empLik"){

    if(restrict == 1){
    mean0mat <- cbind(errs[, u, drop = F]^2 * Y[, v, drop = F],
                      errs[, u, drop = F] * Y[, v, drop = F]^2)
    if(K > 3){
      for(k in 3:(K-1)){
        mean0mat <- cbind(mean0mat,
                          errs[, u, drop = F]^k * Y[, v, drop = F],
                          errs[, u, drop = F] * Y[, v, drop = F]^k)
      }
    }
    } else if (restrict == 2) {
      mean0mat <- cbind(errs[, u, drop = F]^(K-1) * Y[, v, drop = F],
                        errs[, u, drop = F] * Y[, v, drop = F]^(K-1))
    }

    el.out <- emplik::el.test(mean0mat,
                              mu = rep(0, dim(mean0mat)[2]))

    if(verbose){
      cat("Test Indep: ")
      cat(u)
      cat("  --  ")
      cat(v)
      cat(":  ")
      cat(paste(round(colMeans(mean0mat), 3), collapse = " "))
      cat("   p-val: ")
      cat(round(el.out$P, 4))
      cat("\n")
    }
    return(el.out$P)


  } else if(testType == "dhsic"){


    ### UPDATE ###
    dhsic.out <- dHSIC::dhsic.test(errs[,u], Y[,v], method = "gamma")

    if(verbose){
      cat("Test Indep: ")
      cat(u)
      cat("  --  ")
      cat(v)
      cat("   p-val: ")
      cat(round(dhsic.out$p.value, 4))
      cat("\n")
    }
    return(dhsic.out$p.value)

  } else if(testType == "dcov"){


    ### UPDATE ###
    dcov.out <- energy::dcov.test(errs[,u], Y[,v], R = 199)

    if(verbose){
      cat("Test Indep: ")
      cat(u)
      cat("  --  ")
      cat(v)
      cat("   p-val: ")
      cat(round(dcov.out$p.value, 4))
      cat("\n")
    }
    return(dcov.out$p.value)

  }
}




#### Given a node v, check if C is a subset of an(v) \ sib(v)
### Alg 3 from Wang and Drton
testAncestorDebiased <- function(C, v, errs, Y, directEffect, totalEffect, K,
                                 verbose = F, restrict = 1, testType = "empLik"){

  p <- dim(Y)[2]
  beta.fit <- RcppArmadillo::fastLm(errs[, C, drop = F], Y[, v])$coeff
  ancestors <- which(apply(totalEffect[C, , drop = F], MAR = 2, function(x){any(x != 0)}))

  Om.est <- cov(errs)

  # beta.debiased <-  solve(solve(Om.est[C, C, drop = F]) %*% Om.est[C, ancestors, drop = F] %*%
  #                           t(totalEffect[C, ancestors, drop = F])) %*% matrix(beta.fit, ncol = 1)

  if(rcond(Om.est[C, ancestors, drop = F] %*%
           t(totalEffect[C, ancestors, drop = F])) < 1e-10){
    browser()
  }

  beta.debiased <- solve(Om.est[C, ancestors, drop = F] %*%
                            t(totalEffect[C, ancestors, drop = F]), t(errs[, C, drop = F]) %*% Y[, v]) / dim(Y)[1]

  directEffect1 <- directEffect
  directEffect[v, C] <- beta.debiased
  directEffect[v, -C] <- 0

  if(rcond(diag(rep(1, p)) - directEffect) < 1e-15){
    browser()
    cat("!! Conditioning Error !!\n")
    print(paste("rcond: ", rcond(diag(rep(1, p)) - directEffect)))
    print(paste("rcond mod1: ", rcond(Om.est[C, ancestors, drop = F] %*%
                                   t(totalEffect[C, ancestors, drop = F]))))
    print(t(errs[, C, drop = F]) %*% Y[, v])
    print(C)
    print(beta.debiased)
    print(beta.fit)
    print(directEffect1)
    print(totalEffect)
    print(Om.est)
  }

  totalEffect <- round(solve(diag(rep(1, p)) - directEffect), 10)

  res.v <- c(Y[, v] - errs[, ancestors, drop = F] %*% t(totalEffect[v, ancestors, drop = F]))

  if(testType == "empLik"){
    if(restrict == 1){
      mean0mat <- cbind(errs[, C, drop = F]^2 * res.v,
                        errs[, C, drop = F] * res.v^2)
      if(K > 3){
        for(k in 3:(K-1)){
          mean0mat <- cbind(mean0mat,
                            errs[, C, drop = F]^k * res.v,
                            errs[, C, drop = F] * res.v^k)
        }
      }
    } else if (restrict == 2){
      mean0mat <- cbind(errs[, C, drop = F]^(K-1) * res.v,
                        errs[, C, drop = F] * res.v^(K-1))
    }

    el.out <- emplik::el.test(mean0mat,
                              mu = rep(0, dim(mean0mat)[2]))

    if(verbose){
      print("Test Ancestor")
      cat(paste(C, collapse =""))
      cat("  -->  ")
      cat(v)
      cat(":  ")
      cat(paste(round(colMeans(mean0mat), 3), collapse = " "))
      cat("   p-val: ")
      cat(round(el.out$P, 4))
      cat("\n")
    }
    return(el.out$P)


  }  else if(testType == "dhsic"){


    ### UPDATE ###
    dhisc.out <- dHSIC::dhsic.test(errs[, C, drop = F], res.v, method = "gamma")

    if(verbose){
      print("Test Ancestor")
      cat(paste(C, collapse =""))
      cat("  -->  ")
      cat(v)
      cat(":  p-val:")
      cat(round(dhisc.out$p.value, 4))
      cat("\n")
    }
    return(dhisc.out$p.value)

  } else if(testType == "dcov"){


    ### UPDATE ###
    dcov.out <- energy::dcov.test(errs[, C, drop = F], res.v, R = 199)

    if(verbose){
      cat("Test Indep: ")
      cat(u)
      cat("  --  ")
      cat(v)
      cat("   p-val: ")
      cat(round(dcov.out$p.value, 4))
      cat("\n")
    }
    return(dcov.out$p.value)

  }
}

#### When C is \hat pa(v), updates the direct and total effects
### Alg 3 from Wang and Drton
updateDebiased <- function(C, v, errs, Y, directEffect, totalEffect, K, verbose = F){
  if(length(C) > 0){
    p <- dim(Y)[2]
    beta.fit <- RcppArmadillo::fastLm(errs[, C, drop = F], Y[, v])$coeff
    ancestors <- which(apply(totalEffect[C, , drop = F], MAR = 2, function(x){any(x != 0)}))

    Om.est <- cov(errs)

    beta.debiased <- solve(Om.est[C, ancestors, drop = F] %*%
                             t(totalEffect[C, ancestors, drop = F]), t(errs[, C, drop = F]) %*% Y[, v]) / dim(Y)[1]

    directEffect[v, C] <- beta.debiased
    directEffect[v, -C] <- 0
    totalEffect <- round(solve(diag(rep(1, p)) - directEffect), 10)


    res.v <- c(Y[, v] - errs[, ancestors, drop = F] %*% t(totalEffect[v, ancestors, drop = F]))

    return(list(totalEffect = totalEffect, directEffect = directEffect, res.v = res.v))
  } else {
    return(list(totalEffect = totalEffect, directEffect = directEffect, res.v = errs[, v]))
  }
}


#### Pruning procedure which removes ancestors which are not parents
### Alg 4 from Wang and Drton
pruneParents <- function(pa, v, parents, errs, Y, directEffect, totalEffect, K, verbose = F, restrict = 1, testType = "empLik"){
  if(length(parents) == 1){
    return(testIndep(pa, v, errs, Y, K, verbose, restrict, testType = testType))
  } else{
    return(pruneHelper(pa, v, parents, errs, Y, directEffect, totalEffect, K, verbose, restrict, testType))
  }
}


#### helper for pruneParents step pruning procedure
pruneHelper <- function(pa, v, parents, errs, Y, directEffect, totalEffect, K, verbose = F, restrict = 1, testType = "empLik"){
  p <- dim(Y)[2]
  C <- setdiff(parents, pa)
  beta.fit <- RcppArmadillo::fastLm(errs[, C, drop = F], Y[, v])$coeff
  ancestors <- which(apply(totalEffect[C, , drop = F], MAR = 2, function(x){any(x != 0)}))

  Om.est <- cov(errs)

  beta.debiased <- solve(Om.est[C, ancestors, drop = F] %*%
                           t(totalEffect[C, ancestors, drop = F]), t(errs[, C, drop = F]) %*% Y[, v]) / dim(Y)[1]

  directEffect[v, C] <- beta.debiased
  directEffect[v, -C] <- 0

  totalEffect <- round(solve(diag(rep(1, p)) - directEffect), 10)


  res.v <- c(Y[, v] - errs[, ancestors, drop = F] %*% t(totalEffect[v, ancestors, drop = F]))


  if(testType == "empLik"){
    if(restrict == 1){
      mean0mat <- cbind(errs[, parents, drop = F]^2 * res.v,
                      errs[, parents, drop = F] * res.v^2)
      if(K > 3){
        for(k in 3:(K-1)){
          mean0mat <- cbind(mean0mat,
                          errs[, parents, drop = F]^k * res.v,
                          errs[, parents, drop = F] * res.v^k)
        }
      }

    } else if (restrict == 2) {
      mean0mat <- cbind(errs[, parents, drop = F]^(K-1) * res.v,
                        errs[, parents, drop = F] * res.v^(K-1))

    }
    el.out <- emplik::el.test(mean0mat,
                              mu = rep(0, dim(mean0mat)[2]))

    if(verbose){
      print("Test Ancestor")
      cat(paste(C, collapse =""))
      cat("  -->  ")
      cat(v)
      cat(":  ")
      cat(paste(round(colMeans(mean0mat), 3), collapse = " "))
      cat("   p-val: ")
      cat(round(el.out$P, 4))
      cat("\n")
    }
    return(el.out$P)

  } else if (testType == "dhsic"){

    dhisc.out <- dHSIC::dhsic.test(errs[, parents, drop = F], res.v, method = "gamma")
    if(verbose){
      print("Test Ancestor")
      cat(paste(C, collapse =""))
      cat("  -->  ")
      cat(v)
      cat("   p-val: ")
      cat(round(dhisc.out$p.value, 4))
      cat("\n")
    }
    return(dhisc.out$p.value)
  } else if(testType == "dcov"){


    ### UPDATE ###
    dcov.out <- energy::dcov.test(errs[, parents, drop = F], res.v, R = 199)

    if(verbose){
      cat("Test Indep: ")
      cat(u)
      cat("  --  ")
      cat(v)
      cat("   p-val: ")
      cat(round(dcov.out$p.value, 4))
      cat("\n")
    }
    return(dcov.out$p.value)

  }


}

